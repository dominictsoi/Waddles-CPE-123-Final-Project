/* This model is a static model used for the beginning game animation
 It will be simply display a scene where Waddles, the main character is lost and needs help
 1)Will be rendered with basic shapes
 2)If need be animations can be added. 
 3)Make arms, beak, and eyes all different entities for possible animation
 4)eyes can move to follow mouse. 
 5)arms could flap on click 
 */
color[] iceC = new color[3];
int[] colorStore = new int[640000];
int[] crackStore = new int[22];
float gap=0;
float prev =0;
int endCrack=0;
int crackTime=0;
float zoom=1;
float tzoom=0;
float textEnter =1;
String prevMsg ="";
float rJump =0;
float py=600;
float pj=12.5;
boolean waveU =true;
boolean drop =false;
boolean waddles =false;
float landTime=0;
float blink=0;
PImage title;
boolean game=false;
boolean playPress;
boolean menu=false;
PSys fire[] = new PSys[30];
int sharkTimer, fishTimer, fc;
PShape t, sharkB, sharkT;
ArrayList<Fish> fishes = new ArrayList<Fish>();
ArrayList<Shark> sharks = new ArrayList<Shark>();
void setup () {
  size(800, 800);
  iceC[0] = color(#DEF4F9);
  iceC[1] = color(#ECFBFE);
  iceC[2] = color(#F5FFFF);

  for (int i = 0; i < 640000; i++) {
    colorStore[i]=(int)random(0, 3);
  }
  for (int i=0; i<21; i++)
  {
    crackStore[i]=(int)random(375, 425);
  }
  colorMode(RGB, 255, 255, 255, 100);
  //start a new particle system

  smooth();
  title=loadImage("title.png");
}
void draw () {
  if (game)
    game();
  else
  {
    strokeWeight(3);
    pushMatrix();
    translate(tzoom, tzoom*1.5);
    scale(zoom);
    pushMatrix();
    if (gap>80)
      translate(0, (gap-80)*-1);
    stroke(79, 147, 160);
    drawIceBG();
    if (frameCount>=250)
      scene2();
    if (frameCount<50)
    {
      zoom+=0.01;
      tzoom-=3.8;
    }
    if (frameCount>150&& frameCount<200)
    {
      zoom-=0.01;
      tzoom+=3.8;
    }
    pushMatrix();
    scale(0.9);
    stroke(#000000);
    if (!waddles)
      translate(30, 0);
    else
      translate(30, py-600);
    drawPenguin();
    popMatrix();
    pushMatrix();
    scale(0.8);
    if (!waddles)
      translate(490, 50);
    else
      translate(490, py-550);
    drawPenguin();
    popMatrix();
    popMatrix();
    pushMatrix();
    if (gap<=80)
      translate(0, gap);
    else
    {
      translate(0, 80);
    }
    pushMatrix();
    scale(0.6);
    translate(442, py);
    waddles=true;
    drawPenguin();
    waddles=false;
    popMatrix();
    drawEnd();
    popMatrix();
    popMatrix();
    textControl();

    if (frameCount>18 && pj>-12 && frameCount<275)
    {
      py-=pj;
      pj-=0.5;
      if (rJump<PI/2)
        rJump+=0.1;
    } else if (frameCount<=200)
    {

      if (rJump>0.3)
        rJump-=0.3;
    }
    if (frameCount==275)
      pj=12.5;
    if (frameCount>275)
    {
      if (pj>-12)
      {
        pj-=0.5;
        py-=pj;
      } else
      {
        if (!drop)
        {
          landTime=frameCount;
        }
        drop=true;
        if (frameCount-landTime>=5)
        {
          drop=false;
          pj=12.5;
        }
      }

      if (rJump>1.5)
        waveU=false;
      if (rJump<0.9)
        waveU=true;
      if (waveU)
        rJump+=0.1;
      else
        rJump-=0.1;
    }
    if ((frameCount>1150 && !game)||menu)
      mainMenu();
  }
}
void mainMenu()
{
  image(title, 30, 50);
  strokeWeight(4);
  stroke(#00b300);
  fill(#00ff00);
  if(playPress)
   rect(345, 200, 90, 90);
  else
  rect(335, 190, 110, 110);
  noStroke();
  fill(#00b300);
  if(playPress)
  triangle(375, 220, 375, 270, 415, 245);
  else
  triangle(365, 210, 365, 280, 425, 245);
}
void textControl()
{
  if (frameCount<200)
    drawTextBox("One afternoon, Waddles is spending time with his family on an iceberg.");
  else if (frameCount>=200 && frameCount<300)
    drawTextBox("Suddenly, he hears a loud CRACK!");
  else if (frameCount>=300&& frameCount<500)
    drawTextBox("Oh no! The iceberg is breaking and his parents haven't realized it yet!");
  else if (frameCount>=500 && frameCount<670)
    drawTextBox("Waddles watches helplessly as his family floats away :(");
  else if (frameCount>=670 && frameCount<840)
    drawTextBox("He would chase them, but he's not a very good swimmer.");
  else if (frameCount>=840 && frameCount<1040)
    drawTextBox("The iceberg moved very fast, and now Waddles is far away from home.");
  else if (frameCount>=1040 && frameCount<1210)
    drawTextBox("Waddles needs your help to get back to his family!");
}
void game()
{
  background(0,0,255);
  fishEntry();
  sharkEntry();
}
void scene2()
{
  drawCrack();
  if (endCrack!=840 && frameCount-prev>crackTime)
  {
    endCrack+=40;
    fire[endCrack/40] = new PSys((int)random(5, 35), new PVector(500, crackStore[endCrack/40], 0));
    fire[endCrack/40].setLoc(new PVector(endCrack, crackStore[endCrack/40], 0));

    prev =frameCount;
    crackTime= (int)random(5, 15);
  } else if (endCrack==840 && gap<565) {
    gap+=random(0.3, 0.8);
  }
    
  for (int i =1; i<endCrack/40; i++)
    fire[i].run();
  if (gap!=0)
    newCrack();
}
void drawCrack()
{
  endShape(CLOSE);
  if (gap==0)
    noFill();
  else
    fill(41, 72, 204);
  beginShape();
  for (int i=0; i<endCrack; i+=40)
  {
    vertex(i, crackStore[i/40]+gap);
  }
  for (int i=endCrack-40; i>=0; i-=40)
  {
    vertex(i, crackStore[i/40]);
  }
  endShape(CLOSE);
}
void newCrack()
{
  if (gap<50)
  {
    fill(142, 201, 220);
    beginShape();
    for (int i=0; i<820; i+=40)
    {
      vertex(i, crackStore[i/40]+gap);
    }
    for (int i=800; i>=0; i-=40)
    {
      vertex(i, crackStore[i/40]);
    }
    endShape();
  } else
  {
    fill(142, 201, 220);
    beginShape();
    for (int i=0; i<820; i+=40)
    {
      vertex(i, crackStore[i/40]+50);
    }
    for (int i=800; i>=0; i-=40)
    {
      vertex(i, crackStore[i/40]);
    }
    endShape();
  }
}
void drawEnd()
{ 
  stroke(79, 147, 160);
  fill(41, 72, 204);
  beginShape();
  vertex(0, 650);
  vertex(90, 720);
  vertex(200, 680);
  vertex(230, 700);
  vertex(290, 640);
  vertex(400, 700);
  vertex(510, 700);
  vertex(550, 630);
  vertex(610, 610);
  vertex(700, 650);
  vertex(720, 670);
  vertex(740, 660);
  vertex(760, 690);
  vertex(800, 650);
  vertex(800, 800);
  vertex(0, 800);
  endShape(CLOSE);
  fill(142, 201, 220);
  beginShape();
  vertex(0, 650);
  vertex(90, 720);
  vertex(200, 680);
  vertex(230, 700);
  vertex(290, 640);
  vertex(400, 700);
  vertex(510, 700);
  vertex(550, 630);
  vertex(610, 610);
  vertex(700, 650);
  vertex(720, 670);
  vertex(740, 660);
  vertex(760, 690);
  vertex(800, 650);
  vertex(800, 600);
  vertex(760, 640);
  vertex(740, 610);
  vertex(720, 620);
  vertex(700, 600);
  vertex(610, 560);
  vertex(550, 580);
  vertex(510, 650);
  vertex(400, 650);
  vertex(290, 590);
  vertex(230, 650);
  vertex(200, 630);
  vertex(90, 670);
  vertex(0, 600);
  endShape(CLOSE);
}

void drawIceBG()
{
  loadPixels();
  for (int i = 0; i < 640000; i++) {
    pixels[i] = iceC[colorStore[i]];
  }
  updatePixels();
}

void drawPenguin()
{
  //left flippe
  if ((int)random(0, 200) ==1)
    blink=frameCount;
  noStroke();
  pushMatrix();
  fill(250, 173, 39);
  translate(155, 345);
  if (((frameCount>20 &&frameCount<68)|| (frameCount>275 &&!drop))&&waddles)
    rotate(PI/2);
  rotate(5*PI/6);
  translate(-160, -345);
  ellipse(160, 345, 90, 30);
  popMatrix();
  pushMatrix();
  //right flipper

  fill(250, 173, 39);
  translate(245, 345);
  if (((frameCount>20 && frameCount<68) ||(frameCount>275 &&!drop))&&waddles)
    rotate(PI/2);
  rotate(PI/6);
  translate(-240, -345);
  ellipse(240, 345, 90, 30);
  popMatrix();
  pushMatrix();
  if (((frameCount>15&&frameCount<18)||(frameCount>68&&frameCount<71) || drop)&&waddles)
    translate(0, 10);
  //body head and white stomach
  pushMatrix();
  noStroke();
  translate(200, 200);
  fill(0);
  ellipse(0, 25, 210, 280);
  ellipse(0, -20, 175, 250);
  stroke(1);
  if (waddles)
  {
    fill(255);
    ellipse(0, 55, 125, 180);
  }
  popMatrix();
  //eye R
  if (waddles)
  {
    pushMatrix();
    noStroke();
    translate(225, 115);
    if (frameCount-blink<3)
    {
      fill(0);
      stroke(70, 70, 70);
    } else
      fill(255);
    ellipse(0, 0, 50, 50);
    if (frameCount-blink>=3)
      if (frameCount<=275)
      {
        fill(0);
        ellipse(0, 0, 30, 30);
        fill(255);
        ellipse(-5, -5, 8, 8);
      } else
      {
        fill(0);
        ellipse(0, 0, 40, 40);
        fill(255);
        ellipse(-6, -6, 12, 12);
      }
    popMatrix();
    //eyeL
    pushMatrix();
    translate (175, 115);
    if (frameCount-blink<3)
    {
      fill(0);
      stroke(70, 70, 70);
    } else
      fill(255);
    ellipse(0, 0, 50, 50);
    noStroke();
    if (frameCount-blink>=3)
      if (frameCount<=275)
      {
        fill(0);
        ellipse(0, 0, 30, 30);
        fill(255);
        ellipse(-5, -5, 8, 8);
      } else
      {
        fill(0);
        ellipse(0, 0, 40, 40);
        fill(255);
        ellipse(-6, -6, 12, 12);
      }
    popMatrix();

    //Beak
    pushMatrix();
    stroke(1);
    fill(253, 141, 25);
    triangle(182, 150, 200, 135, 218, 150);
    triangle(185, 150, 200, 165, 215, 150);
    popMatrix();
  }
  //Arm L
  pushMatrix();
  translate(115, 165);
  if (waddles)
    rotate(rJump*2);

  translate(0, 75);
  fill(0);
  ellipse(0, 0, 50, 150);
  popMatrix();
  //Arm R
  pushMatrix();
  translate(285, 165);
  if (waddles)
    rotate(-rJump*2);
  translate(0, 75);
  fill(0);
  ellipse(0, 0, 50, 150);
  popMatrix();
  noStroke();
  if (waddles)
  {
    //eyebrow L
    pushMatrix();
    fill(255);
    translate(160, 80);
    rect(0, 0, 25, 5);
    popMatrix();
    //eyebrow R
    pushMatrix();
    fill(255);
    translate(240, 80);
    rect(0, 0, -25, 5);
    popMatrix();
  }
  popMatrix();
}

void mouseReleased() {
  menu=true;
  if (mouseX >=335 && mouseX<=445 && mouseY>=190 && mouseY<=300)
  {
    game=true;
    fc = frameCount;
    sharkTimer = frameCount;
    fishTimer = frameCount;
  }
}
void mousePressed() {
  if (mouseX >=335 && mouseX<=445 && mouseY>=190 && mouseY<=300)
  {
    playPress=true;
  }
}


class Particle {

  PVector loc;
  PVector vel;
  PVector accel;
  float r;
  float life;

  //constructor
  Particle(PVector start) {
    accel = new PVector(0, 0.05, 0); //gravity
    vel = new PVector(random(-2, 2), random(-6, 0), 0);
    loc = start.get();
    r = 2.0;
    life = random(10, 20);
  }
  void run() {
    updateP();
    renderP();
  }

  //a function to update the particle each frame
  void updateP() {
    vel.add(accel);
    loc.add(vel);
    life -= 1.0;
  }

  //how to draw a particle
  void renderP() {
    pushMatrix();
    ellipseMode(CENTER);
    fill(79, 147, 160);
    translate(loc.x, loc.y);
    ellipse(0, 0, r, r);
    popMatrix();
  }

  //a function to test if a particle is alive
  boolean alive() {
    if (life <= 0.0) {
      return false;
    } else {
      return true;
    }
  }
} //end of particle object definition


//now define a group of particles as a particleSys
class PSys {

  ArrayList particles; //all the particles
  PVector source; //where all the particles emit from
  PVector shade; //their main color
  int n;
  //constructor
  PSys(int num, PVector init_loc) {
    particles = new ArrayList();
    source = init_loc;
    n=num;
    shade = new PVector(random(255), random(255), random(255));
  }
  void setLoc(PVector init_loc)
  {
    source = init_loc;
    for (int i=0; i < n; i++) {
      particles.add(new Particle(source));
    }
  }
  //what to do each frame
  void run() {
    //go through backwards for deletes
    for (int i=particles.size()-1; i >=0; i--) {
      Particle p = (Particle) particles.get(i);
      //update each particle per frame
      p.run();
      if ( !p.alive()) {
        particles.remove(i);
      }
    }
  }

  //is particle system still populated?
  boolean dead() {
    if (particles.isEmpty() ) {
      return true;
    } else {
      return false;
    }
  }
}
void drawTextBox(String msg)
{
  if (!prevMsg.equals(msg))
    textEnter=1;
  strokeWeight(5);
  stroke(199, 168, 75);
  fill(40, 80, 105);
  rect(150, 710, 500, 80);
  fill(255, 255, 255);
  textAlign(CENTER, CENTER);
  textSize(20);
  try {
    for (int i=0; i<textEnter; i++)
    {
      text(msg.substring(0, (int)textEnter), 160, 705, 480, 80);
    }
  }
  catch (Exception e)
  {
    text(msg.substring(0, (int)msg.length()), 160, 705, 480, 80);
  }
  if (textEnter<msg.length())
    textEnter+=0.4;
  prevMsg = msg;
}
void sharkEntry() {
  if (frameCount - sharkTimer > random(300, 420))
  {
    sharks.add(new Shark(800, (int)random(0, height)));
    sharks.get(0).sharkBody();
    sharkTimer = frameCount;
  }
  for (int i = 0; i < sharks.size(); i++)
  {
    sharks.get(i).sharkBody();
  }
}

class Shark {
  PShape sharkB;
  PShape sharkT;
  float rad=0;
  float vel = 0;
  boolean up;
  int cX, cY;
  Shark(int x, int y) {
    cX = x;
    cY = y;
  }

  void sharkBody() {

    sharkB=createShape();
    sharkB.beginShape();
    sharkT=createShape();
    beginShape();
    fill(color(166, 195, 229));
    sharkB.vertex(130, 262);
    sharkB.vertex(136, 266);
    sharkB.vertex(144, 272);
    sharkB.vertex(148, 275);
    sharkB.vertex(154, 276);
    sharkB.vertex(159, 273);
    sharkB.vertex(163, 272);
    sharkB.vertex(167, 270);
    sharkB.vertex(173, 270);
    sharkB.vertex(179, 268);
    sharkB.vertex(184, 270);
    sharkB.vertex(184, 273);
    sharkB.vertex(184, 276);
    sharkB.vertex(179, 278);
    sharkB.vertex(175, 282);
    sharkB.vertex(173, 284);
    sharkB.vertex(172, 286);
    sharkB.vertex(180, 286);
    sharkB.vertex(188, 288);
    sharkB.vertex(198, 288);
    sharkB.vertex(207, 290);
    sharkB.vertex(212, 290);
    sharkB.vertex(218, 289);
    sharkB.vertex(223, 289);
    sharkB.vertex(230, 291);
    sharkB.vertex(243, 294);
    sharkB.vertex(252, 294);
    sharkB.vertex(262, 294);
    sharkB.vertex(270, 294);
    sharkB.vertex(278, 291);
    sharkB.vertex(283, 292);
    sharkB.vertex(293, 290);
    sharkB.vertex(301, 288);
    sharkB.vertex(306, 288);
    sharkB.vertex(319, 283);
    sharkB.vertex(332, 279);
    sharkB.vertex(345, 274);
    sharkB.vertex(349, 272);
    sharkB.vertex(360, 277);
    sharkB.vertex(364, 277);
    sharkB.vertex(370, 277);
    sharkB.vertex(370, 272);
    sharkB.vertex(373, 269);
    sharkB.vertex(377, 270);
    sharkB.vertex(382, 273);
    sharkB.vertex(389, 274);
    sharkB.vertex(395, 276);
    sharkB.vertex(398, 277);
    sharkB.vertex(394, 271);
    sharkB.vertex(394, 266);
    sharkB.vertex(397, 266);
    sharkB.vertex(394, 261);
    sharkB.vertex(393, 253);
    sharkB.vertex(396, 249);
    sharkB.vertex(396, 248);
    sharkB.vertex(390, 246);
    sharkB.vertex(381, 242);
    sharkB.vertex(375, 241);
    sharkB.vertex(371, 238);
    sharkB.vertex(370, 234);
    sharkB.vertex(370, 230);
    sharkB.vertex(372, 229);
    sharkB.vertex(375, 227);
    sharkB.vertex(377, 227);
    sharkB.vertex(371, 226);
    sharkB.vertex(365, 226);
    sharkB.vertex(358, 228);
    sharkB.vertex(351, 229);
    sharkB.vertex(345, 227);
    sharkB.vertex(337, 224);
    sharkB.vertex(328, 220);
    sharkB.vertex(318, 218);
    sharkB.vertex(310, 213);
    sharkB.vertex(300, 211);
    sharkB.vertex(294, 211);
    sharkB.vertex(290, 207);
    sharkB.vertex(287, 199);
    sharkB.vertex(289, 193);
    sharkB.vertex(289, 187);
    sharkB.vertex(292, 183);
    sharkB.vertex(291, 180);
    sharkB.vertex(284, 180);
    sharkB.vertex(276, 182);
    sharkB.vertex(271, 185);
    sharkB.vertex(265, 189);
    sharkB.vertex(258, 193);
    sharkB.vertex(251, 198);
    sharkB.vertex(245, 203);
    sharkB.vertex(238, 207);
    sharkB.vertex(235, 210);
    sharkB.vertex(225, 213);
    sharkB.vertex(216, 215);
    sharkB.vertex(206, 219);
    sharkB.vertex(192, 224);
    sharkB.vertex(180, 228);
    sharkB.vertex(172, 231);
    sharkB.vertex(163, 236);
    sharkB.vertex(152, 240);
    sharkB.vertex(144, 246);
    sharkB.vertex(139, 249);
    sharkB.vertex(133, 254);
    sharkB.vertex(130, 256);
    sharkB.vertex(128, 261);
    sharkB.endShape(CLOSE);
    sharkTail();
    drawShark(cX, cY);
  }


  void sharkTail() {  
    fill(color(166, 195, 229));
    sharkT.vertex(392, 260);
    sharkT.vertex(396, 251);
    sharkT.vertex(401, 247);
    sharkT.vertex(408, 244);
    sharkT.vertex(415, 240);
    sharkT.vertex(423, 236);
    sharkT.vertex(428, 229);
    sharkT.vertex(435, 223);
    sharkT.vertex(442, 215);
    sharkT.vertex(450, 208);
    sharkT.vertex(455, 203);
    sharkT.vertex(460, 199);
    sharkT.vertex(460, 197);
    sharkT.vertex(460, 205);
    sharkT.vertex(460, 211);
    sharkT.vertex(460, 218);
    sharkT.vertex(458, 222);
    sharkT.vertex(455, 229);
    sharkT.vertex(451, 234);
    sharkT.vertex(448, 241);
    sharkT.vertex(445, 247);
    sharkT.vertex(441, 252);
    sharkT.vertex(437, 254);
    sharkT.vertex(432, 257);
    sharkT.vertex(428, 260);
    sharkT.vertex(428, 262);
    sharkT.vertex(428, 266);
    sharkT.vertex(432, 271);
    sharkT.vertex(435, 275);
    sharkT.vertex(437, 279);
    sharkT.vertex(438, 281);
    sharkT.vertex(441, 282);
    sharkT.vertex(441, 285);
    sharkT.vertex(434, 283);
    sharkT.vertex(429, 282);
    sharkT.vertex(424, 278);
    sharkT.vertex(419, 276);
    sharkT.vertex(415, 274);
    sharkT.vertex(407, 269);
    sharkT.vertex(405, 269);
    sharkT.vertex(399, 267);
    sharkT.vertex(398, 268);
    endShape(CLOSE);
  }
  void drawShark(int x, int y) {//image(img1, 75, 100);
    //whole Shark Control
    pushMatrix();
    translate(vel, 0);
    vel += random(-3.5, -0.5);
    //SHARK HITBOX
    fill(166, 195, 229, 50);
    rect(x+125, y+175, 345, 120);
    ////////////////////////////
    pushMatrix();
    translate(x, y);
    shape(sharkB);//shark body
    pushMatrix();
    translate(-1*(cX+65), 0);
    rotate(rad);
    pushMatrix();
    translate(cX+65, 0);
    shape(sharkT);//shark tail
    popMatrix();


    fill(0);
    ellipse(162, 256, 5, 5);
    if (up==true) {
      rad-=0.003;
    } else {
      rad+=0.003;
    }

    if (rad>radians(0.1)||rad<radians(-0.1)) {
      up=!up;
    }

    popMatrix();
    //ellipse used to cover the tail and body merge. 

    noStroke();
    fill(166, 195, 229);
    ellipse(397, 258, 18, 17);
    strokeWeight(1);
    stroke(0);

    popMatrix();
    popMatrix();
  }
}

void fishEntry() {
  if (frameCount - fishTimer > random(240, 420))
  {
    fishes.add(new Fish(850, (int)random(0, height)));
    fishes.get(0).makeTail();
    fishTimer = frameCount;
  }
  for (int i = 0; i < fishes.size(); i++)
  {
    fishes.get(i).makeTail();
  }
}

class Fish {
  int fx, fy;
  boolean up=true;
  float rad = 0;
  float vel = 0;
  Fish(int x, int y) {
    fx=x;
    fy=y;
  }

  void makeTail() {
    t=createShape();
    t.beginShape();
    scale(1);
    t.fill(233, 136, 19);
    t.vertex(35, -13);
    t.vertex(45, -20);
    t.vertex(50, -22);
    t.vertex(55, -24);
    t.vertex(60, -25);
    t.vertex(63, -20);
    t.vertex(63, -15);
    t.vertex(61, -5);
    t.vertex(62, 0);
    t.vertex(63, 10);
    t.vertex(62, 15);
    t.vertex(60, 15);
    t.vertex(55, 14);
    t.vertex(50, 13);
    t.vertex(45, 12);
    t.vertex(40, 11);
    t.vertex(35, 11);
    t.endShape(CLOSE);
    drawFish(fx, fy);
  }


  void drawFish(int x, int y) {
    pushMatrix();
    translate(vel, 0);
    vel += random(-3.5, -0.5);
    fill(233, 136, 19, 50);
    //HITBOXES FOR FISH
    rect(x-45, y-30, 120, 55);
    /////////////////////
    strokeWeight(0.7);
    int w=80;
    int h=3*w/5;
    pushMatrix();
    translate(x, y);
    fill(233, 136, 20);
    pushMatrix();

    translate(-40, 0);
    rotate(rad);
    pushMatrix();
    translate(40, 0);
    shape(t);
    popMatrix();

    popMatrix();

    ellipse(0, 0, w, h);
    popMatrix();
    //eye
    fill(255);
    ellipse(x-20, y-5, 12.5, 12.5);//watch this when we scale
    fill(30);
    ellipse(x-20, y-5, 8, 8);
    fill(255);
    ellipse(x-22, y-6, 4, 4);
    noFill();
    arc(x-10, y, w/8, h/2, -PI/2, PI/2);
    fill(color(166, 195, 229));
    popMatrix();
    endShape();
    if (up==true) {
      rad-=0.01;
    } else {
      rad+=0.01;
    }

    if (rad>radians(2.5)||rad<radians(-1)) {
      up=!up;
    }
  }
}
